'use strict';
exports.__esModule = true;
var Atomizer = require("atomizer");
var cssnano = require("cssnano");
var loader_utils_1 = require("loader-utils");
var postcss = require("postcss");
var utils_1 = require("./utils");
var DEFAULT_CSS_DEST = './build/css/atomic.css';
var DEFAULT_POSTCSS_PLUGIN_LIST = [];
// cached response to prevent unnecessary update
var cachedResponse = '';
var atomizer = new Atomizer({ verbose: true });
// Hash to keep track of config loaded by path
var configObject = {
    "default": {
        configs: {
            classNames: []
        }
    }
};
var parseAndGenerateFile = function (configPath, source, validPostcssPlugins, minimize) {
    if (validPostcssPlugins === void 0) { validPostcssPlugins = []; }
    if (minimize === void 0) { minimize = false; }
    return new Promise(function (resolve, reject) {
        var firstTrigger = configObject[configPath] || true;
        if (firstTrigger && configPath) {
            configObject[configPath] = require(require.resolve(configPath));
        }
        var pathConfig = configObject[configPath] || configObject["default"];
        var foundClasses = atomizer.findClassNames(source);
        var cssDest = pathConfig.cssDest || DEFAULT_CSS_DEST;
        if (!utils_1.ensureExists(cssDest)) {
            console.warn('[atomic loader] create css failed.');
            return;
        }
        // custom rules file
        if (pathConfig.options && pathConfig.options.rules) {
            var customRules = require(require.resolve(pathConfig.options.rules));
            if (customRules) {
                atomizer.addRules(customRules);
            }
        }
        var finalConfig = atomizer.getConfig(foundClasses, pathConfig.configs || {});
        var cssString = atomizer.getCss(finalConfig, pathConfig.options || {});
        var pipeline = postcss(validPostcssPlugins);
        if (minimize) {
            pipeline.use(cssnano());
        }
        pipeline.process(cssString).then(function (result) {
            var _a = result.css, css = _a === void 0 ? '' : _a;
            if (css === cachedResponse) {
                return resolve();
            }
            utils_1.writeCssFile(cssDest, css)
                .then(function () {
                cachedResponse = css;
                return resolve();
            })["catch"](function (err) { return reject(err); });
        });
    });
};
var atomicLoader = function (source, map) {
    var callback = this.async();
    if (this.cacheable) {
        this.cacheable();
    }
    var query = loader_utils_1.getOptions(this) || {};
    var _a = query.minimize, minimize = _a === void 0 ? false : _a, _b = query.postcssPlugins, postcssPlugins = _b === void 0 ? [] : _b;
    var validPostcssPlugins = DEFAULT_POSTCSS_PLUGIN_LIST;
    if (Array.isArray(postcssPlugins)) {
        validPostcssPlugins = postcssPlugins;
    }
    var configPaths = query.configPath;
    if (!Array.isArray(configPaths)) {
        configPaths = [configPaths];
    }
    var tasks = configPaths.map(function (configPath) {
        return parseAndGenerateFile(configPath, source, validPostcssPlugins, minimize);
    });
    Promise.all(tasks)
        .then(function () {
        return callback(null, source);
    })["catch"](function (err) {
        return callback(err, source);
    });
};
// export default atomicLoader
module.exports = atomicLoader;
